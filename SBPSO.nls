;# This is based on fsancho PSO.nls im using that as a template or almost :)
;# The thing is, SBPSO works in a different way compared to PSO. One thing is that graphically we can't say that elements are near or far away from each other, because we have  
;# just a set of numbers with no positions and no order. Now, in terms of velocity and position, our position is a set of numbers contained in our universe set (U) and this 
;# position has a value returned by a fitness function and with this value we can say what position is better. A velocity is another set of numbers with variable size but
;# it contains also an operator which indicates an addition or subtraction of that element in our current set of position, so if we have something like this:
;# Position: X = {a, c} (considering size of 2 elements it can be more..) and Velocity: V = {(+,b), (âˆ’, c)} (considering size of 2 pairs of elements it can be more..)
;# then we will get a returned position of: ResultPosition: X'= {a,b}. 
;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #




breed [AI:particles AI:particle]
turtles-own
[
  personal-best-val   ; mejor valor que he encontrado
  personal-best-pos ; the attributes which make this the best
  posi
  velocity
]


; Main Procedure report. It gives iter repetitions of step function, and returns the 
; position and value of the (possibly local) maximum found.




to-report updateVelocity [turt]
    let unionAuxAi union (union posi personal-best-pos) global-best-pos
    let Ai filter [x -> not member? x unionAuxAi] (sort U)
    
    let auxSi (list posi personal-best-pos global-best-pos);Just putting up X, P.best and G.best in a list of 3 to reduce after
    let Si reduce intersect auxSi ;Intersection of X P.best and G.best
    
    let k count elements with [member? (element who) Ai]
    ;c1 and c2 are atraction constants to personal and global best
    set velocity (union (prodVel (#atraction-best-personal * (random-float 1.0)) (difference personal-best-pos posi)) 
                        (prodVel (#atraction-best-global * (random-float 1.0)) (difference global-best-pos posi))) ;remains to put ->
    set velocity union velocity (k-tournamentSelection k posi)
    let auxVel round((random-float 1.0) * (length Si))
    set velocity union velocity n-of auxVel Si
    let temp sentence (last velocity) (n-of auxVel Si)
    set velocity (list first velocity temp)
    report velocity
end

;AUXILIARY FUNCTIONS

to-report union [set1 set2]
  let ret se set1 set2
  report remove-duplicates ret
end

to-report difference [set1 set2]
  let differenceSet1 filter [x -> not member? x set2] set1 ;elements in set1 but not in set2
  let differenceSet2 filter [x -> not member? x set1] set2 ;elements in set2 but not in set1
  report (list differenceSet1 differenceSet2) ;first set with additions and second one with deletions
end

to-report applyVel [posit vel] ;apply a velocity to a position
  let retPos posit
  set retPos filter [x -> not member? x (last vel)] posit ;"deleting" items on second list of the velocity from the given position
  set retPos se retPos (first vel) ;adding the first list of the velocity to the given position
  set retPos remove-duplicates retPos ;to be sure that we doesn't have duplicates
  report retPos
end

to-report prodVel [eta V] ;picks a random subset from V with probability of eta
  let n floor (eta * length V)
  report n-of n V
end

to-report intersect [a b] ;auxiliar function to easily intersect 3 lists
   report (filter [x -> member? x b] a)
end

to-report k-tournamentSelection [k sol]
  let tempList sol ;make a temporary list which starts out to be the local solution of the turtle
  let bestSol sol ;best solution is the same but will be modified turing the algoritm
  let solPoints 0
  let bestSolPoints 0
  let velo [] ;initialize velocity set
  let Ai (elements with [not member? (element who) sol and not member? (element who) personal-best-pos and not member? (element who) global-best-pos])
  if count Ai > 0 [
  let elemToAdd one-of Ai
  repeat k [
    ask one-of Ai [ ;randomly choose one element which is not already in the solution
      set tempList lput (element who) bestSol ; add this element to the temporary list in order to compare if this solution is better
      set solPoints evalPosition tempList ; evaluate the solution
      if solPoints > bestSolPoints [ ;update bestSolution
        set bestSolPoints solPoints
        set elemToAdd (element who) ;is the element which will be added as velocity
      ]
    ]
  ]
    set velo lput elemToAdd velo ]
  report list velo []
end

to set-random-solution
  ask turtles [
    set personal-best-pos []
    repeat ( random (poblacion mod 7) + 1 ) [
      set personal-best-pos lput  (one-of elements) personal-best-pos
      set personal-best-val evalPosition personal-best-pos
    ]
  ]
end




to set-global-solution[turt]
    foreach global-best-pos [ ele ->
      ask ele [
        set color blue
        set part-of-global-best? false
      ]
    ]
  ask turtle turt [
    set global-best-pos personal-best-pos  ; the attributes which make this the best
    set global-best-value personal-best-val   ; best value found yet

    foreach global-best-pos [ ele ->
      ask ele [
        set color red
        set part-of-global-best? true
      ]
    ]
  ]
end