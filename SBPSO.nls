;# This is based on fsancho PSO.nls im using that as a template or almost :)
;# The thing is, SBPSO works in a different way compared to PSO. One thing is that graphically we can't say that elements are near or far away from each other, because we have  
;# just a set of numbers with no positions and no order. Now, in terms of velocity and position, our position is a set of numbers contained in our universe set (U) and this 
;# position has a value returned by a fitness function and with this value we can say what position is better. A velocity is another set of numbers with variable size but
;# it contains also an operator which indicates an addition or subtraction of that element in our current set of position, so if we have something like this:
;# Position: X = {a, c} (considering size of 2 elements it can be more..) and Velocity: V = {(+,b), (−, c)} (considering size of 2 pairs of elements it can be more..)
;# then we will get a returned position of: ResultPosition: X'= {a,b}. 
;# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

extensions[Rnd]
globals [
  global-best-pos ;gonna be a set which stores the global best set (position)
  global-best-value ;gonna be a set which stores the value of that position (fitness function return)
  U ;gonna be a set, basically our search space
]

breed [AI:particles AI:particle]

AI:particles-own [
  velocity ;The velocity is a set of operation pairs {(+,a),(-,b)..}
  pos ;The position is a set of elements from the universe of discourse (U) 
  personal-best-value ;gonna be the best value found of the pos below
  personal-best-pos ;gonna be the best set found 
  evaluation ; This is the returned value of fitness function of this particle position
]

to AI:Create-particles [#population #dimension] ;Dimension will be the size of our particle position set and Population will be the number of particles
  create-AI:particles #population [ ;Creates #population number of particles
    set pos n-values #dimension [random U] ;random elements of our U
    set velocity [] ;creates an empty list velocity variable
    set evaluation AI:evaluation ;AI:evaluation needs to be provided by the program which runs along with this .nls (like knapsack problem) which has the fitness function
    set personal-best-value evaluation ;The value of the position below (initial)
    set personal-best-pos pos ;The starting position is the initial best personal value (initial)
  ]
  let best min-one-of (AI:particles with-max [evaluation]) [who] ;Store the best particle yet
  set global-best-value [personal-best-value] of best ;Store the value of best
  set global-best-pos [personal-best-pos] of best ;Store the pos (set) of best
end

; Main Procedure report. It gives iter repetitions of step function, and returns the 
; position and value of the (possibly local) maximum found.

to-report AI:SBPSO [#iters #inertia-particle #atraction-best-personal #atraction-best-global #lim-vel-particles] 
  repeat #iters [
    AI:SBPSO-step #inertia-particle #atraction-best-personal #atraction-best-global #lim-vel-particles ;Calling the main function
    AI:PSOExternalUpdate
  ]
  report (list global-best-value global-best-pos)
end

; Step procedure where the PSO lgorithm is executing
to AI:SBPSO-step [#inertia-particle #atraction-best-personal #atraction-best-global #lim-vel-particles]
  ; First, check if the best values must be updated (personals and global)
  ask AI:particles [
    if evaluation > personal-best-value ;In this case we need to update the personal best position
    [
      set personal-best-value evaluation ;Changing its value with the new best found
      set personal-best-pos pos ;Changing its pos set with the new best found
    ]
  ]
  let best min-one-of (AI:particles with-max [personal-best-value]) [who] ;We update the global best too if its the case
  set global-best-value [personal-best-value] of best ;Same
  set global-best-pos [personal-best-pos] of best ;Same

;Now comes the hard part, we need to create some aux functions to implement all the operators listed, and to be able to work with the different kind of sets that we have here
;code below not valid part of the "template"

  ; Then, update velocities and positions of every particle
  ask AI:particles
  [
    ; 
    ; Consider the inertia
    set velocity *v #inertia-particle velocity
    
    ; Attraction to personal best
    let to-personal-best-pos -v personal-best-pos pos
    set velocity +v velocity (*v ((1 - #inertia-particle) * #atraction-best-personal * (random-float 1.0)) to-personal-best-pos)
    
    ; Attraction to global best
    let to-global-best -v global-best-pos pos
    set velocity  +v velocity (*v ((1 - #inertia-particle) * #atraction-best-global * (random-float 1.0)) to-global-best)

    ; Bound the velocity
    let n norm velocity
    if n > #lim-vel-particles [set velocity (*v ( #lim-vel-particles / n) velocity)]
    
    ; Update the position of the particle
    set pos map cut01 (+v pos velocity)
    set evaluation AI:evaluation
  ]
end

;AUXILIARY FUNCTIONS

to-report union [set1 set2]
  let ret se set1 set2
  report remove-duplicates ret
end

to-report difference [set1 set2] ; 0 -> "+", 1 -> "-"
  let differenceSet filter [x -> not member? x set2] set1
  let first-op[]
  let second-op[]
  let aux[]
  foreach differenceSet [x -> 
    set aux lput 0 aux
    set aux lput x aux
    set first-op lput aux first-op
    set aux []
  ]
  set differenceSet filter [x -> not member? x set1] set2
   foreach differenceSet [x -> 
    set aux lput 1 aux
    set aux lput x aux
    set first-op lput aux first-op
    set aux []
  ]
  report (union first-op second-op)
end
;rnd:weighted-one-of-list list anonymous-reporter
;The probability of each item being picked is proportional to the weight given by the anonymous-reporter for that item. 

to-report randPickVel [V prob] ;not finished yet..
  let global []
  let lista (range 1 length V)
  let lista1 (n-values (length V - 1) [i -> ((i + 1) * prob) / (length V - 1)])
  let pairs (map list lista lista1)
  set global rnd:weighted-n-of-list (first rnd:weighted-one-of-list (map list lista lista1) last) V [prob]
  let prueba (first rnd:weighted-one-of-list pairs [ [p] -> last p ])
  let prueba2 lista1
 report prueba
end

to-report applyVel [posit vel] ;apply a velocity to a position
  let retPos posit
  foreach vel [x ->
    ;if we find 0 in the sublist it means that we need to add that number to the given position, if its 1 we need to remove that number
    ;from the given position if it exist(can be the case)
    ifelse (first x = 0) [set retPos lput (last x) retpos] [set retPos remove (last x) retPos] 
  ]
  report retPos
end
;-----------------------------------------------------------------------------------------------------------------------------------------------------
;Algorithm
;
;Set N equal to the number of particles in the swarm;
;for i = 1, . . . ,N do
;Initialize Xi as random subset of U;
;Initialize Vi = 0;
;Calculate f (Xi);
;Initialize f (Yi) = -infinite;
;Initialize f (bYi) = -infinite;
;end
;while stopping condition is false do
;for i = 1, . . . ,N do
;// set the personal best position;
;if f (Xi) > f (Yi) then
;Yi = Xi;
;end
;// set the neighborhood best position;
;for all neighbors l of particle i do
;if ( f (Yi) > f (bYl) then
;bYl =Yi;
;end
;end
;end
;for i = 1, . . . ,N do
;Update Vi according to equation (4.7); turtle-set turtleset-S turtleset-T for union
;Vi(t+1) = c1*r1 SCALARMULT (Yi(t)) DIFFERENCE Xi(t)) ADDITION c2*r2 SCALARMULT (^Yi(t) DIFFERENCE Xi(t)) ADDITION (c3*r3 ADDITIONELEM Ai(t)) ADDITION
;(c4*r4 REMOVEELEM Si(t))

;c1 y c2 pertenecen a [0,1]
;c3 y c4 pertenecen a [0,|U|]
;Los numeros random ri se sacan de una distribucion normal (0,1) independientemente
;Ai(t) = U\(Xi(t) Union Yi(t) Union ^Yi(t)) y Si(t) = Xi(t) Intersec Yi(t) Intersec ^Yi(t)

;Update Xi according to equation (4.8);
;X i(t+1) = Xi(t) ADDVELPOS Vi(t+1)
;Calculate f (Xi);
;end
;end



; Irrelevant stuff
; ATRACCION
; En PSO la particula estaba atraida por el personal best, global best, etc. En SBPSO ocurre la misma atraccion por el personal best
; Si te fijas en la la figura b que hay en el pdf el movimiento de X(t) hacia Y(t) en SBPSO significa que los dos sets se hacen mas similares con
; eliminar los elementos de X(t) que no estan en Y(t) y añadiendo a X(t) los elementos que faltan en Y(t) y los elementos que estan en los dos sets
; no se ven afectados por esta atraccion.

; VELOCIDAD
; La velocidad la vamos a denotar mediante un par de elementos, que va a consistir en la adicion y supresion de elementos. 
; Como ejemplo: Considerando la posicion X = {a, c} y velocidad V = {(+,b), (−, c)}, añadir la velocidad V a la posicion X significa que el elemento
; b se va a añadir mientras que el elemento c se va a suprimir, quedando una posicion: X'= {a,b}

; A particle is an subset of U
; Population: number of particles to be created
; Dimesion: dimension of U
; AI:evaluation es el valor de la particula, es decir, la salida de f(Xi), la f.fitness estará en el .nlogo que incluya este .nls

