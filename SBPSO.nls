globals [
  global-best-pos ;gonna be a set
  global-best-value ;gonna be a set
  U
]

breed [AI:particles AI:particle]

AI:particles-own [
  velocity ;The velocity is a set of operation pairs (Vi(t) be the velocity of particle i at iteration t)
  pos ;The position is a set of elements from the universe of discourse U (Xi(t) be the position of particle i at iteration t, a subset of U)
  personal-best-value ;gonna be a set
  personal-best-pos ;gonna be a set
  evaluation ;gonna be a set
]
; ATRACCION
; En PSO la particula estaba atraida por el personal best, global best, etc. En SBPSO ocurre la misma atraccion por el personal best
; Si te fijas en la la figura b que hay en el pdf el movimiento de X(t) hacia Y(t) en SBPSO significa que los dos sets se hacen mas similares con
; eliminar los elementos de X(t) que no estan en Y(t) y añadiendo a X(t) los elementos que faltan en Y(t) y los elementos que estan en los dos sets
; no se ven afectados por esta atraccion.

; VELOCIDAD
; La velocidad la vamos a denotar mediante un par de elementos, que va a consistir en la adicion y supresion de elementos. 
; Como ejemplo: Considerando la posicion X = {a, c} y velocidad V = {(+,b), (−, c)}, añadir la velocidad V a la posicion X significa que el elemento
; b se va a añadir mientras que el elemento c se va a suprimir, quedando una posicion: X'= {a,b}
; La velocidad sigue la siguiente fórmula: vi,j(t + 1) = w vi,j(t)+c1*r1,j(t) [yi, j(t)−xi, j(t)]+c2*r2,j(t) [ˆyi,j(t) − xi,j(t)]

; A particle is an subset of U
; Population: number of particles to be created
; Dimesion: dimension of U
; AI:evaluation es el valor de la particula, es decir, la salida de f(Xi), la f.fitness estará en el .nlogo que incluya este .nls

to AI:Create-particles [#population #dimension]
  create-AI:particles #population [
    ;random elements of our U
    set pos n-values #dimension [random U]
    set velocity [] ;velocity set size same as pos?
    set evaluation AI:evaluation
    ; The starting position is the initial best personal value
    
    set personal-best-value evaluation
    set personal-best-pos pos
  ]
  let best min-one-of (AI:particles with-max [evaluation]) [who]
  set global-best-value [personal-best-value] of best
  set global-best-pos [personal-best-pos] of best
end


; Main Procedure report. It gives iter repetitions of step function, and returns the 
; position and value of the (possibly local) maximum found.

to-report AI:SBPSO [#iters #inertia-particle #atraction-best-personal #atraction-best-global #lim-vel-particles]
  repeat #iters [
    AI:SBPSO-step #inertia-particle #atraction-best-personal #atraction-best-global #lim-vel-particles
    AI:PSOExternalUpdate
  ]
  report (list global-best-value global-best-pos)
end


; Step procedure where the PSO lgorithm is executing
to AI:SBPSO-step [#inertia-particle #atraction-best-personal #atraction-best-global #lim-vel-particles]
  ; First, check if the best values mus be updated (personals and global)
  ask AI:particles [    
    if evaluation > personal-best-value
    [
      set personal-best-value evaluation
      set personal-best-pos pos
    ]
;    if global-best-value < personal-best-value
;    [
;      set global-best-value personal-best-value
;      set global-best-pos personal-best-pos
;    ]
  ]
  let best min-one-of (AI:particles with-max [personal-best-value]) [who]
  set global-best-value [personal-best-value] of best
  set global-best-pos [personal-best-pos] of best

  ; Then, update velocities and positions of every particle
  ask AI:particles
  [
    ; 
    ; Consider the inertia
    set velocity *v #inertia-particle velocity
    
    ; Attraction to personal best
    let to-personal-best-pos -v personal-best-pos pos
    set velocity +v velocity (*v ((1 - #inertia-particle) * #atraction-best-personal * (random-float 1.0)) to-personal-best-pos)
    
    ; Attraction to global best
    let to-global-best -v global-best-pos pos
    set velocity  +v velocity (*v ((1 - #inertia-particle) * #atraction-best-global * (random-float 1.0)) to-global-best)

    ; Bound the velocity
    let n norm velocity
    if n > #lim-vel-particles [set velocity (*v ( #lim-vel-particles / n) velocity)]
    
    ; Update the position of the particle
    set pos map cut01 (+v pos velocity)
    set evaluation AI:evaluation
  ]
end

;Algorithm
;
;Set N equal to the number of particles in the swarm;
;for i = 1, . . . ,N do
;Initialize Xi as random subset of U;
;Initialize Vi = 0;
;Calculate f (Xi);
;Initialize f (Yi) = -infinite;
;Initialize f (bYi) = -infinite;
;end
;while stopping condition is false do
;for i = 1, . . . ,N do
;// set the personal best position;
;if f (Xi) > f (Yi) then
;Yi = Xi;
;end
;// set the neighborhood best position;
;for all neighbors l of particle i do
;if ( f (Yi) > f (bYl) then
;bYl =Yi;
;end
;end
;end
;for i = 1, . . . ,N do
;Update Vi according to equation (4.7); turtle-set turtleset-S turtleset-T for union
;Vi(t+1) = c1*r1 SCALARMULT (Yi(t)) DIFFERENCE Xi(t)) ADDITION c2*r2 SCALARMULT (^Yi(t) DIFFERENCE Xi(t)) ADDITION (c3*r3 ADDITIONELEM Ai(t)) ADDITION
;(c4*r4 REMOVEELEM Si(t))

;c1 y c2 pertenecen a [0,1]
;c3 y c4 pertenecen a [0,|U|]
;Los numeros random ri se sacan de una distribucion normal (0,1) independientemente
;Ai(t) = U\(Xi(t) Union Yi(t) Union ^Yi(t)) y Si(t) = Xi(t) Intersec Yi(t) Intersec ^Yi(t)

;Update Xi according to equation (4.8);
;X i(t+1) = Xi(t) ADDVELPOS Vi(t+1)
;Calculate f (Xi);
;end
;end


